### select 方法空转
    若 Selector 的轮询结果为空，也没有 wakeup 或新消息处理，则发生空轮询，CPU使用率 100%，
    Netty的解决办法：对 Selector 的 select 操作周期进行统计，
    每完成一次空的 select 操作进行一次计数。
    若在某个周期内连续发生N次空轮询，则触发了 epoll 死循环 bug 。
    重建 Selector 判断是否是其他线程发起的重建请求，
    若不是则将原 SocketChannel 从旧的 Selector 上去除注册，
    重新注册到新的 Selector 上，并将原来的 Selector 关闭
    
### ThreadPoolExecutor 构造函数重要参数：
    corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。
    maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
    workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
    keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；
    unit ：keepAliveTime 参数的时间单位。
    threadFactory ：executor 创建新线程的时候会用到。
    handler ：饱和策略
    
### Synchronized原理
    1. Java中的每一个对象都可以作为锁
        1.对于同步方法，锁是当前实例对象
        2.对于静态同步方法，锁是当前对象的Class对象
        3.对于同步方法块，锁是Synchonized括号里配置的对象
        
    2. Synchronized vs ReentrantLock
        1.synchronized 是 Java 关键字，ReentrantLock 是基于 AQS 的 API 层面的互斥锁
        2.ReentrantLock 设置等待超时时间
        3.ReentrantLock 可进行公平锁与非公平锁设置
        4.ReentrantLock 可绑定多个 Condition
        5.synchronized 不需要手动释放锁
        6.synchronized 可以修饰方法、代码块

### Threadlocal原理
### IOC
    1.循环依赖
        1.Spring 为了解决单例的循环依赖问题，使用了 三级缓存 ，递归调用时发现 Bean 还在创建中即为循环依赖

### CAP
    1.数据一致性模型 (强一致性，弱一致性，最终一致性)
    2.一致性解决方案
        1.分布式事务：两段提交
        2.分布式锁
        3.MQ 消息持久化 重试 幂等
        4.Paxos 算法
    3.高可用解决方案
        1.熔断是减少由于下游服务故障对自己的影响；而降级则是在整个系统的角度上，考虑业务整体流量，保护核心业务稳定
        
### 高并发下的流量控制
    1.令牌桶(Token Bucket)、漏桶(leaky bucket)和 计数器 算法是最常用的三种限流的算法
    2.漏桶 准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行
    3.令牌桶 
    4.redis 计数来做集群限流
    5.nginx 限流
    
### 分布式
    1.缓存
        1. 缓存与数据库不一致问题
            1.更新操作数据库后，再次更新缓存来实现
            2.缓存设置过期时间，等待过期时间后，数据恢复
    2.分布式锁
        1. redis 分布式锁 setnx
        2. ZooKeeper 的分布式锁
            1.使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点
            2.创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点
            3.如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功
            4.如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的 前一个节点 添加一个事件监听
    3.分布式事物
        1.2PC/XA方案 (有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务)
        2.TCC 方案
            1.Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行 锁定或者预留
            2.Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作
            3.Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要 进行补偿，就是执行已经执行成功的业务逻辑的回滚操作
        3.可靠消息最终一致性方案
            1.基于 MQ 来实现事务
        4.最大努力通知方案
        
    4.消息队列
    5.zookeeper
        1. ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M
        2. 
    6.kafka
    7.dubbo/dubbox
        1.
    
                              